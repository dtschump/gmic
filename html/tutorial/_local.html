<!DOCTYPE html>
<html lang="en-us"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="tutorial.css">
<script type="text/javascript" src="highslide/highslide.js"></script>
<link rel="stylesheet" type="text/css" href="highslide/highslide.css" />
<script type="text/javascript">
hs.graphicsDir = 'highslide/graphics/';
hs.wrapperClassName = 'wide-border';
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<body>


      



<h1 id="local">-local &hellip; -endlocal</h1>
<div id="Frame1" style="float: left; width: 325px; height: 325px; border: none; padding: 0in;"><img src="http://www.particularart.com/static/media/uploads/command_reference/local/lcl-00.png" title="lcl-00.png" class="img_block" style="margin: 3px; border: 0px solid #808080;" height="300" width="300" /></div>
<p>The <tt>local ... -endlocal</tt> pair establishes a <i>local</i> (or <i>inner</i>) list consisting of the selected images in the command's <a target="_parent" href="command-decorations.shtml">right hand decoration</a>. These images then form a subset of the <i>global</i> (or <i>outer</i>) list. The command takes no arguments. <tt>-l</tt> and <tt>-endl</tt> are shorthand forms.</p>
<p>The <tt>-local</tt> command often insulates images of the outer list from a series of operations that are intended for a particular subset. The <tt>-local</tt> command can also rearrange disparately placed images to form simpler contiguous sequences so that they may be referenced more easily. For example, one can put every fourth image from an outer list onto an inner list of contiguous elements through <tt>-local[0--1:4]... -endlocal</tt> and then be able to address elements of the inner list without having to account for the stride distance that separates these images on the outer list.</p>
<p>In a sense, the <tt>-local</tt> command preselects a set of images for extended operations and forms a <i>local scope </i>while that command is in effect, so that subsequent pipeline operations only affect images in that scope. At the same time, the <tt>-local</tt> command masks images <i>not</i> in -local's right hand decorator. These masked images and their indices effectively disappear, leaving only the selected images composing the local list.</p>
<p>When it is first constituted, the selected images on the local list are in the same relative order as their placement on the global list. Their enumeration changes, however, and are counted with respect to the beginning of the local list, the outer list enumeration has no bearing while a <tt>-local</tt> command is in effect and using it to address local images is unpredictable.</p>
<p>While the <tt>-local</tt> command is in effect, images on the local list may be altered, reordered and removed and new images may appear. These circumstances persists until an <tt>-endlocal</tt> command executes. After such, the local list (but not its contents!) ceases to exist, and the masked images on the global list reappear, undisturbed by any operation that had executed while the <tt>-local</tt> command was active. As much as possible, <tt>-endlocal</tt> preserves the final ordering of items on the local list. Pairs of images that occupied disjoint positions prior to the execution of a <tt>-local</tt> command again become separated by the same intervening images. After <tt>-endlocal</tt> executes, images created on the local list retain as neighbors their immediate predecessors, as there were no intervening images separating them from their predecessors.</p>
<p><tt>-local[&gt;$] ... -endlocal</tt> pairs may nest to an arbitrary depth. It is a common coding error to have unbalanced pairings of the two commands. One usually borrows the practice from shell scripting to place these commands on their own lines and indent intermediary lines by a constant amount.</p>
<h2 id="ListIteration">List Iteration</h2>
<p>The idiom:</p>
<p><tt>... -verbose - -repeat $! -local[&gt;$]... -endlocal -done -verbose +...</tt></p>
<p>constructs an image list iterator and is probably the single most common use of the <tt>-local</tt> command. Most G'MIC commands which are implemented outside of the <tt>Cimg.h</tt> C++ template (that is to say, a majority of G'MIC commands) employ this idiom as a template, with the implementation nestled within the <tt>-local[&gt;$] ... -endlocal</tt> pair.</p>
<p>With this idiom, a designer generally can work out the details of a G'MIC command acting on one image. The corresponding multiple image implementation follows effortlessly by placing the single image implementation within the <tt>-local[&gt;$] ... -endlocal</tt> pair.</p>
<p>In the G'MIC language, the interpreter replaces instances of the substitution sequence <tt>'$!'</tt> with the number of images on the list, setting up the iterator to cycle as many times as there are images on the list. In kind, the interpreter replaces instances of the substitution sequence <tt>'$&gt;'</tt> with the current loop count of the next outermost <tt>-repeat ... -done</tt> pair. Consequently, on each loop, <tt>-local[&gt;$]</tt> creates a one image local list consisting of the image indexed by the current loop count. The bulk of the implementation can then be designed to operate on just that item; it need not be aware that a larger list exists.</p>
<h3 id="ListCreationAndListIteration">Image Creation and List Iteration</h3>
<p>G'MIC does not disallow image creation in the inner <tt>-local &hellip; -endlocal</tt> block of a list iterator. However, neither the state of the list nor the images on the list are indexed in any particular way when -repeat <em>n</em> executes. The <em>n</em> argument sets the number of iterations at the outset; that value does not change. If circumstances occuring within the loop add or remove images on the list, then some images on the list will be excluded (or included!) in the span of the iteration during the course of its run. This can lead to some bemusing circumstances. Consider the following:</p>
<p><tt>$ gmic -input pick_a_color_one.png -input pick_a_color_two.png -input pick_a_color_three.png \<br /> -repeat $! \<br /> &nbsp;&nbsp; -local[$&gt;] \<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --select_color[-1] 20%,255,128,0 \<br /> &nbsp;&nbsp; -endlocal \<br /> -done \</tt></p>
<p>Perhaps it was the programmer's intent to create one selection mask for any orange-red like colors that might be within each of the three initial images on the list, while preserving the originals for other purposes. Indeed, that is exactly what happens in the first iteration. However, on the second loop <tt>($&gt;==1)</tt> the operand that winds up on the local list is <em>not</em> <tt>pick_a_color_two.png</tt>, but the mask created from <tt>pick_a_color_one.png</tt> during the previous iteration. This calamity arises because when <tt>-endlocal</tt> executes at the conclusion of the first iteration, the mask created from <tt>pick_a_color_one.png</tt> becomes the new successor image of <tt>pick_a_color_one.png</tt>, displacing <tt>pick_a_color_two.png</tt>. As a consequence, masks are never made of the second or subsequent input images. Masks, masks of masks, and masks of masks of masks, and so on, are made instead. Probably this is not what the programmer had in mind.</p>
<p>In this particular case, a remedy may be obtained by modifying the right hand decoration of the <tt>-local</tt> command so as to account for the stride created by the insertion of new images.</p>
<p style="text-align: center;"><tt>&hellip;-local[2*$&gt;]&hellip;</tt></p>
<p>The fix succeeds because the programmer knows that only one image is being created within the <tt>-local</tt> block per iteration and that image will become the immediate successor of the operand. Given this, he or she can stride over it, anticipating that indices of the initial images will double as new images appear. By selecting every even-indexed image, the -local command essentially skips over the newly created images.</p>
<p>General cases may be more complicated, however. In any case, when a G'MIC programmer creates images within the inner block of a list iterator, he or she will have to account for how many, and where, the new images will be merged and adjust the stride computations in the right hand decorator of the <tt>-local</tt> command to accommodate.</p>
<h2 id="ExceptionProcessingWithOnFail">Exception Processing with <tt>-onfail</tt></h2>
<p>Inserting <tt>-onfail</tt> within the block formed by <tt>-local &hellip; -endlocal</tt> creates an exception handler. The <tt>-onfail</tt> command splits the local block into <em>normal</em> and <em>exception</em> processing components.</p>
<p>The exception processor has three features:</p>
<ol>
<li>Commands between <tt>-local</tt> and <tt>-onfail</tt> always execute. These constitute the normal processing component.</li>
<li>Script errors or failures occuring in the normal processing component are <em>caught</em> by the <tt>-onfail</tt> command. The G'MIC interpreter does not exit with an error message. Instead, the interpreter begins executing the commands making up the exception processor, if any exist. These consist of the commands between <tt>-onfail</tt> and <tt>-endlocal.</tt></li>
<li>The status substitution sequence, <tt>${}</tt>, resolves to the error message that the G'MIC prints to the error stream. The interpreter still prints this message, but does not exit.</li>
</ol>
<p>One is not obligated to write commands for the exception handler. <tt>-onfail</tt> itself catches the exception, and if there are no commands within the exception block, the G'MIC interpreter continues processing the commands following the <tt>-local &hellip; -endlocal</tt> block.</p>
<h3 id="OnFailExample">-onfail Example</h3>
<p><tt> -local[]<br /> &nbsp;-input nosuchimage.png<br /> &nbsp;-echo[] "Have 'No Such Image'."<br /> &nbsp;-onfail<br /> &nbsp;-echo[] ${}<br /> -endlocal<br /> -echo[] "The script is executing here!"</tt></p>
<p>If there is no such image as <tt>nosuchimage.png</tt>, the G'MIC interpreter throws an exception, which, in the absence of a <tt>-nofail</tt> command, terminates the script. In this example, <tt>-onfail</tt> catches the the exception. Observe that when the exception is thrown, the first <tt>-echo</tt> command, and any commands following, will not execute. For all practical purposes, the exception causes the interpreter to skip ahead to the first command following <tt>-onfail</tt>, here the second <tt>-echo</tt> command, which executes. This second <tt>-echo</tt> command illustrates a simple, but redundant, use of the status substitution sequence, which the interpreter replaces with the error message associated with the exception. It's illustrative, but redundant, as the G'MIC interpreter echoes the error message in any case. We trust the reader can conceive of more interesting behavior.</p>
<p>When exception processing is complete, the G'MIC interpreter exits the local scope and executes the third -echo command following. This -echo command executes almost in any case, unless a second, uncaught, exception occurs in the exception processor itself.</p>
<p>Though it is probably clear to the reader, it is worth noting that a second exception occuring in the exception processor will not be caught unless the programmer writes another&nbsp;<tt>-local &hellip; -onfail<tt> &hellip; </tt> -endlocal</tt> block, nested within the exception processor itself. Such an elaboration is permissible, and, in principle, there no limits to how elaborate an exception processor may be. Practice, custom and programmer sanity usually dictate simple exception processors, however, the kind including no commands whatsoever being quite common.&nbsp;</p>
<p>It is also probably clear to the reader that the scope of a particular exception processor is limited to the immediate enclosing <tt>-local &hellip; -onfail<tt> &hellip; </tt> -endlocal</tt> block. Errors in an enclosing block are uncaught unless the enclosing block itself is a <tt>-local &hellip; -onfail<tt> &hellip; </tt> -endlocal</tt> block.</p>
<p><em>Garry Osgood</em></p>



   
</body></html>